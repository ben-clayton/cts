{"version":3,"sources":["../../../../src/webgpu/api/validation/createComputePipeline.spec.ts"],"names":["description","params","poptions","makeTestGroup","ValidationTest","F","getShaderModule","shaderStage","entryPoint","code","device","createShaderModule","getInvalidShaderModule","pushErrorScope","shaderModule","popErrorScope","doCreateComputePipelineTest","isAsync","_success","descriptor","shouldResolve","createComputePipelineAsync","shouldReject","createComputePipeline","expectValidationError","g","test","desc","cases","fn","t","compute","module","combine","shaderModuleStage","shaderModuleEntryPoint","stageEntryPoint"],"mappings":"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","sourcesContent":["export const description = `\ncreateComputePipeline and createComputePipelineAsync validation tests.\n`;\n\nimport { params, poptions } from '../../../common/framework/params_builder.js';\nimport { makeTestGroup } from '../../../common/framework/test_group.js';\n\n// import { kAllTextureFormats, kAllTextureFormatInfo } from '../../capability_info.js';\nimport { ValidationTest } from './validation_test.js';\n\ntype TShaderStage = 'compute' | 'vertex' | 'fragment' | 'empty';\n\nclass F extends ValidationTest {\n  getShaderModule(\n    shaderStage: TShaderStage = 'compute',\n    entryPoint: string = 'main'\n  ): GPUShaderModule {\n    let code;\n    switch (shaderStage) {\n      case 'compute': {\n        code = `[[stage(compute), workgroup_size(1)]] fn ${entryPoint}() {}`;\n        break;\n      }\n      case 'vertex': {\n        code = `\n        [[stage(vertex)]] fn ${entryPoint}() -> [[builtin(position)]] vec4<f32> {\n          return vec4<f32>(0.0, 0.0, 0.0, 1.0);\n        }`;\n        break;\n      }\n      case 'fragment': {\n        code = `\n        [[stage(fragment)]] fn ${entryPoint}() -> [[location(0)]] vec4<i32> {\n          return vec4<i32>(0, 1, 0, 1);\n        }`;\n        break;\n      }\n      case 'empty':\n      default: {\n        code = '';\n        break;\n      }\n    }\n    return this.device.createShaderModule({ code });\n  }\n\n  getInvalidShaderModule(): GPUShaderModule {\n    this.device.pushErrorScope('validation');\n    const code = 'deadbeaf'; // Something make nonsense\n    const shaderModule = this.device.createShaderModule({ code });\n    this.device.popErrorScope();\n    return shaderModule;\n  }\n\n  doCreateComputePipelineTest(\n    isAsync: boolean,\n    _success: boolean,\n    descriptor: GPUComputePipelineDescriptor\n  ) {\n    if (isAsync) {\n      if (_success) {\n        this.shouldResolve(this.device.createComputePipelineAsync(descriptor));\n      } else {\n        this.shouldReject('OperationError', this.device.createComputePipelineAsync(descriptor));\n      }\n    } else {\n      if (_success) {\n        this.device.createComputePipeline(descriptor);\n      } else {\n        this.expectValidationError(() => {\n          this.device.createComputePipeline(descriptor);\n        });\n      }\n    }\n  }\n}\n\nexport const g = makeTestGroup(F);\n\ng.test('basic_use_of_createComputePipeline')\n  .desc(\n    `\nControl case for createComputePipeline and createComputePipelineAsync.\nCall the API with valid compute shader and matching valid entryPoint, making sure that the test function working well.\n`\n  )\n  .cases(poptions('isAsync', [true, false]))\n  .fn(async t => {\n    const { isAsync } = t.params;\n    t.doCreateComputePipelineTest(isAsync, true, {\n      compute: { module: t.getShaderModule('compute', 'main'), entryPoint: 'main' },\n    });\n  });\n\ng.test('shader_module_must_be_valid')\n  .desc(\n    `\nTests calling createComputePipeline(Async) with a invalid compute shader, and check that the APIs catch this error.\n`\n  )\n  .cases(poptions('isAsync', [true, false]))\n  .fn(async t => {\n    const { isAsync } = t.params;\n    t.doCreateComputePipelineTest(isAsync, false, {\n      compute: {\n        module: t.getInvalidShaderModule(),\n        entryPoint: 'main',\n      },\n    });\n  });\n\ng.test('shader_module_stage_must_be_compute')\n  .desc(\n    `\nTests calling createComputePipeline(Async) with valid but different stage shader and matching entryPoint,\nand check that the APIs only accept compute shader.\n`\n  )\n  .cases(\n    params()\n      .combine(poptions('isAsync', [true, false]))\n      .combine(poptions('shaderModuleStage', ['compute', 'vertex', 'fragment'] as TShaderStage[]))\n  )\n  .fn(async t => {\n    const { isAsync, shaderModuleStage } = t.params;\n    const descriptor = {\n      compute: {\n        module: t.getShaderModule(shaderModuleStage, 'main'),\n        entryPoint: 'main',\n      },\n    };\n    t.doCreateComputePipelineTest(isAsync, shaderModuleStage === 'compute', descriptor);\n  });\n\ng.test('enrty_point_name_must_match')\n  .desc(\n    `\nTests calling createComputePipeline(Async) with valid compute stage shader and different entryPoint,\nand check that the APIs only accept matching entryPoint.\n\nThe entryPoint in shader module include standard \"main\" and others.\nThe entryPoint assigned in descriptor include:\n- Matching case (control case)\n- Empty string\n- Mistyping\n- Containing invalid char, including space and control codes (Null character)\n`\n  )\n  .cases(\n    params()\n      .combine(poptions('isAsync', [true, false]))\n      .combine([\n        { shaderModuleEntryPoint: 'main', stageEntryPoint: 'main' },\n        { shaderModuleEntryPoint: 'main', stageEntryPoint: '' },\n        { shaderModuleEntryPoint: 'main', stageEntryPoint: 'main\\0' },\n        { shaderModuleEntryPoint: 'main', stageEntryPoint: 'main\\0a' },\n        { shaderModuleEntryPoint: 'main', stageEntryPoint: 'mian' },\n        { shaderModuleEntryPoint: 'main', stageEntryPoint: 'main ' },\n        { shaderModuleEntryPoint: 'main', stageEntryPoint: 'ma in' },\n        { shaderModuleEntryPoint: 'main', stageEntryPoint: 'main\\n' },\n        { shaderModuleEntryPoint: 'mian', stageEntryPoint: 'mian' },\n        { shaderModuleEntryPoint: 'mian', stageEntryPoint: 'main' },\n        { shaderModuleEntryPoint: 'mainmain', stageEntryPoint: 'mainmain' },\n        { shaderModuleEntryPoint: 'mainmain', stageEntryPoint: 'foo' },\n        { shaderModuleEntryPoint: 'main_t12V3', stageEntryPoint: 'main_t12V3' },\n        { shaderModuleEntryPoint: 'main_t12V3', stageEntryPoint: 'main_t12V5' },\n        { shaderModuleEntryPoint: 'main_t12V3', stageEntryPoint: '_main_t12V3' },\n      ])\n  )\n  .fn(async t => {\n    const { isAsync, shaderModuleEntryPoint, stageEntryPoint } = t.params;\n    const descriptor = {\n      compute: {\n        module: t.getShaderModule('compute', shaderModuleEntryPoint),\n        entryPoint: stageEntryPoint,\n      },\n    };\n    const _success = shaderModuleEntryPoint === stageEntryPoint;\n    t.doCreateComputePipelineTest(isAsync, _success, descriptor);\n  });\n"],"file":"createComputePipeline.spec.js"}